import os
import json
import subprocess
from pathlib import Path
from datetime import datetime

# Define base directory relative to this script's location
TOOL_BASE_DIR = Path(__file__).parent
# LOKI_ROOT_DIR should be the parent of the 'nodes' directory
LOKI_ROOT_DIR = TOOL_BASE_DIR.parent.parent

# Define expected location of the filter_nodes script
FILTER_NODES_SCRIPT_PATH = LOKI_ROOT_DIR / "nodes" / "filter_nodes" / "filter_nodes_node.py"

# Define where the list nodes output their files (NEW LOCATIONS)
LIST_INSTALLED_NODE_OUTPUT_DIR = LOKI_ROOT_DIR / "nodes" / "list_installed_nodes" / "output"
LIST_AVAILABLE_NODE_OUTPUT_DIR = LOKI_ROOT_DIR / "nodes" / "list_available_nodes" / "output"


def ensure_workflow_dir(workflow_name):
    """Create workflow directory if it doesn't exist"""
    workflow_dir = LOKI_ROOT_DIR / "workflows" / workflow_name
    workflow_dir.mkdir(parents=True, exist_ok=True)
    return workflow_dir

def load_workflow_requests():
    """Load workflow requests from JSON file"""
    requests_file = TOOL_BASE_DIR / "workflow_requests.json"
    if not requests_file.exists():
         print(f"Error: workflow_requests.json not found at {requests_file}")
         return {}
    with open(requests_file, "r") as f:
        return json.load(f)

def load_workflow_info(workflow_dir):
    """Load workflow.json if it exists"""
    workflow_file = workflow_dir / "workflow.json"
    if workflow_file.exists():
        with open(workflow_file, "r") as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                 print(f"Warning: Corrupted workflow.json in {workflow_dir}. Initializing.")
                 return {"status": "error", "error": {"message": "Corrupted workflow.json"}}
    return {"status": "pending"}

def save_workflow_info(workflow_dir, info):
    """Save workflow.json"""
    workflow_file = workflow_dir / "workflow.json"
    with open(workflow_file, "w") as f:
        json.dump(info, f, indent=2, default=str) # Use default=str for datetime


def process_workflow(workflow_name, workflow_data):
    """Process a single workflow by calling the standalone filter script"""
    workflow_dir = ensure_workflow_dir(workflow_name)

    # Load or initialize workflow info
    workflow_info = load_workflow_info(workflow_dir)

    # Check status
    if workflow_info.get("status") == "completed":
        print(f"[SKIP] {workflow_name} (already completed)")
        return
    elif workflow_info.get("status") == "processing":
         print(f"[WARN] {workflow_name} was in processing state. Retrying.")
         # Optionally reset state or handle differently

    print(f"\n[START] Processing {workflow_name}")
    print(f"Description: {workflow_data.get('description', '')}")

    # Define input files (UPDATED PATHS if documentation dir is also moved, but assuming it stays at root for now)
    # Assuming documentation generated by list_* nodes still goes to root documentation folder
    documentation_dir = LOKI_ROOT_DIR / "documentation"
    installed_nodes_md = LIST_INSTALLED_NODE_OUTPUT_DIR / "installed_nodes_detailed.md"
    available_nodes_md = LIST_AVAILABLE_NODE_OUTPUT_DIR / "available_nodes.md"

    # Check if input files exist (optional but recommended)
    if not installed_nodes_md.exists():
         print(f"[ERROR] Input file not found: {installed_nodes_md}")
         workflow_info.update({"status": "error", "error": {"message": f"Input file missing: {installed_nodes_md.name}"}})
         save_workflow_info(workflow_dir, workflow_info)
         return
    if not available_nodes_md.exists():
        print(f"[ERROR] Input file not found: {available_nodes_md}")
        workflow_info.update({"status": "error", "error": {"message": f"Input file missing: {available_nodes_md.name}"}})
        save_workflow_info(workflow_dir, workflow_info)
        return

    try:
        # Update workflow status
        workflow_info.update({
            "name": workflow_name,
            "data": workflow_data, # Store original request data
            "description": workflow_data.get("description", ""),
            "requirements": workflow_data.get("requirements", []),
            "status": "processing",
            "timestamp": datetime.now().isoformat(),
            "processed_inputs": {}, # Track which inputs were processed
            "output_files": {} # Track output files
        })
        save_workflow_info(workflow_dir, workflow_info)

        # --- Run filter_nodes.py for installed nodes ---
        print(f"[RUN] Filtering INSTALLED nodes for {workflow_name}...")
        output_installed_filtered = workflow_dir / "installed_nodes_filtered.md"
        cmd_installed = [
            "python", str(FILTER_NODES_SCRIPT_PATH),
            "--input", str(installed_nodes_md),
            "--output", str(output_installed_filtered),
            "--prompt", workflow_data["description"]
            # Add --threshold or --batch-size if needed from workflow_data
        ]
        # Use subprocess.run for simpler execution if real-time output isn't critical
        result_installed = subprocess.run(cmd_installed, capture_output=True, text=True, check=False) # check=False to handle errors manually

        print(result_installed.stdout) # Print stdout from the script
        if result_installed.returncode != 0:
             print(f"[ERROR] Filtering installed nodes failed (Code: {result_installed.returncode})\n{result_installed.stderr}")
             raise subprocess.CalledProcessError(result_installed.returncode, cmd_installed, stderr=result_installed.stderr)
        else:
             workflow_info["processed_inputs"]["installed_nodes"] = str(installed_nodes_md.relative_to(LIST_INSTALLED_NODE_OUTPUT_DIR.parent))
             workflow_info["output_files"]["installed_nodes_filtered"] = str(output_installed_filtered.relative_to(LOKI_ROOT_DIR)) # Store relative path
             print("[DONE] Filtering installed nodes.")


        # --- Run filter_nodes.py for available nodes ---
        print(f"[RUN] Filtering AVAILABLE nodes for {workflow_name}...")
        output_available_filtered = workflow_dir / "available_nodes_filtered.md"
        cmd_available = [
            "python", str(FILTER_NODES_SCRIPT_PATH),
            "--input", str(available_nodes_md),
            "--output", str(output_available_filtered),
            "--prompt", workflow_data["description"]
             # Add --threshold or --batch-size if needed
        ]
        result_available = subprocess.run(cmd_available, capture_output=True, text=True, check=False)

        print(result_available.stdout)
        if result_available.returncode != 0:
             print(f"[ERROR] Filtering available nodes failed (Code: {result_available.returncode})\n{result_available.stderr}")
             raise subprocess.CalledProcessError(result_available.returncode, cmd_available, stderr=result_available.stderr)
        else:
            workflow_info["processed_inputs"]["available_nodes"] = str(available_nodes_md.relative_to(LIST_AVAILABLE_NODE_OUTPUT_DIR.parent))
            workflow_info["output_files"]["available_nodes_filtered"] = str(output_available_filtered.relative_to(LOKI_ROOT_DIR))
            print("[DONE] Filtering available nodes.")

        # Update status to completed
        workflow_info["status"] = "completed"
        print(f"[SUCCESS] {workflow_name} completed successfully.")
        save_workflow_info(workflow_dir, workflow_info)

    except subprocess.CalledProcessError as e:
        print(f"[FATAL ERROR] {workflow_name} failed during subprocess execution:\n  Command: {' '.join(e.cmd)}\n  Stderr: {e.stderr}")
        workflow_info.update({"status": "error", "error": {"message": f"Subprocess failed code {e.returncode}", "command": ' '.join(e.cmd), "stderr": e.stderr}})
        save_workflow_info(workflow_dir, workflow_info)
    except Exception as e:
         print(f"[FATAL ERROR] Unexpected error processing {workflow_name}: {e}")
         workflow_info.update({"status": "error", "error": {"message": f"Unexpected error: {str(e)}", "type": type(e).__name__}})
         save_workflow_info(workflow_dir, workflow_info)


def main():
    """Main execution function for the build tool"""
    print("--- Starting Workflow Build Process ---")
    # Ensure base workflows directory exists
    (LOKI_ROOT_DIR / "workflows").mkdir(exist_ok=True)
    # Ensure documentation directory exists (where inputs are expected)
    (LOKI_ROOT_DIR / "documentation").mkdir(exist_ok=True)

    # Also ensure the *node* output dirs exist before the tool runs
    LIST_INSTALLED_NODE_OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    LIST_AVAILABLE_NODE_OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    # Load workflow requests
    workflow_requests = load_workflow_requests()
    if not workflow_requests:
         print("No workflow requests found. Exiting.")
         return

    # Process each workflow
    print(f"Found {len(workflow_requests)} workflow requests.")
    for workflow_name, workflow_data in workflow_requests.items():
        process_workflow(workflow_name, workflow_data)

    print("\n--- Workflow Build Process Finished ---")


if __name__ == "__main__":
    main() 